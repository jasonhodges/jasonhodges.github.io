[{"attributes":{"layout":"post","title":"Angular Conditional Number Format","topic":"angular","categories":"blog","permalink":"/blog/Angular-Conditional-Number-Format/","comments":true,"excerpt":"Solution to a little number formatting issue I worked out","seo__desc":"directive to format a number depending on type","seo__key":"Angular, AngularJS, directives, formatting, Denver CO","urlTitle":"Angular-Conditional-Number-Format","id":0},"body":"This is just a bit of code demonstrating the ability to use Angular's inline filtering capability to format numbers depending on another piece of data. I had a scenario where the numbers passed to the view could represent numeric units or monetary units. In order to keep the code lean and reusable I chose the following method. \n\nThe three lines below reside in the directive template file. \n\n`liability-list.template.html`\n\n```HTML\nAvailable: {{ (t.UnitType == \"Dollars\") ? (t.UnitsAvailable | currency:'$') : (t.UnitsAvailable | number:0) }}\nUsed: {{ (t.UnitType == \"Dollars\") ? (t.UnitsUsed | currency:\"$\") : (t.UnitsUsed | number:0) }}\nMax: {{ (t.UnitType == \"Dollars\") ? (t.UnitValue | currency:\"$\") : (t.UnitValue | number:0) }}\n```\n\nThis is the directive that handles it all. \n\n\n`liabilityItem.directive.js`\n```JavaScript\n(function () {\n  'use strict';\n\n  angular\n    .module('starter')\n    .directive('liabilityItem', liabilityItem);\n\n  function liabilityItem() {\n    var directive = {\n      scope: {\n        t: '=itemData',\n      },\n      templateUrl: './liability-list.template.html',\n      link: link,\n      restrict: 'E'\n    };\n    return directive;\n  }\n})();\n```\n\n\nLastly, this is the snippet of code from within the index file of the view.  The 'tier' is an array of objects provided via controller.\n\n`index.html`\n```HTML\n<liability-Item\n  ng-repeat=\"t in tier\"\n  item-data=\"t\">\n</liability-Item>\n```\n","frontmatter":"layout : post\ntitle : Angular Conditional Number Format\ntopic: angular\ncategories : blog\npermalink : /blog/Angular-Conditional-Number-Format/\ncomments : true\nexcerpt: Solution to a little number formatting issue I worked out\nseo__desc : directive to format a number depending on type\nseo__key : Angular, AngularJS, directives, formatting, Denver CO","path":"assets/posts/2016-03-03-angular-conditional-number-format.md"},{"attributes":{"layout":"post","title":"Angular Dynamic Styles","topic":"angular","type":"article","categories":"blog","permalink":"/blog/Angular-Dynamic-Styles/","comments":true,"excerpt":"Solution to a problem that needed dynamic styling.","seo__desc":"solution to produce dynamic styling","seo__key":"Angular, styling, Angular Material, Denver CO","urlTitle":"Angular-Dynamic-Styles","id":1},"body":"Material Tabs have a default min-width of `160px` so the ink bar looks wide for any tab names that are short. The request was to have the ink bar extend approximitely `4px` from the left and right sides of the tab text. In order to acheive this in a way that would be dynamic to account for changes in tab font size or text, the below solution was developed. \n\nThe `nav` component was given a template name of `#shopNav`\n```html\n<nav mat-tab-nav-bar #shopNav class=\"shop-nav-tabs\" [disableRipple]=\"true\" [backgroundColor]=\"'white'\">\n```\n\nNext, the individual tabs where given a `(click)` event that calls a function, passing in a numerical value of the index for the tab.\n```html\n    <a mat-tab-link\n       [routerLink]=\"shopLinks[0].path\"\n       routerLinkActive #rlaa=\"routerLinkActive\"\n       (click)=\"doSomething(0)\"\n       [active]=\"rlaa.isActive\">\n        {{shopLinks[0].label}}\n    </a>\n    <div class=\"pad-lg-l\"></div>\n    <a mat-tab-link\n       [routerLink]=\"shopLinks[1].path\"\n       routerLinkActive #rlab=\"routerLinkActive\"\n       (click)=\"doSomething(1)\"\n       [active]=\"rlab.isActive\">\n        {{shopLinks[1].label}}\n    </a>\n    <div class=\"pad-xl-l\"></div>\n    <a mat-tab-link\n       [routerLink]=\"shopLinks[2].path\"\n       routerLinkActive #rlac=\"routerLinkActive\"\n       (click)=\"doSomething(2)\"\n       [active]=\"rlac.isActive\">\n        {{shopLinks[2].label}}\n    </a>\n</nav>\n```\n\nThis takes care of the template for the Material Tab component. \n\n---\n\nLets walk from the top down through the component class, explaining each piece of the solution.\n```Typescript\nimports...\n\n@Component({\n    selector: 'smp-shop',\n    templateUrl: './shop.component.html',\n    styleUrls: ['./shop.component.scss']\n})\nexport class ShopComponent implements OnInit, AfterViewInit, OnDestroy {\n```\nWe declare the nav template name as a `ViewChild` within the component. This provides us access to a plethora of values under the `nativeElement`. \n```Typescript\n    @ViewChild('shopNav') shopNav: any;\n```\nThe variable `inkBar` is declared and typed as `ElementRef`. Once the view has been initialized, `inkBar` will be assigned the value of `this.shopNav._inkbar._elementRef`. This allows us to type `this.inkBar.nativeElement` instead of having to remember to type `this.shopNav._inkBar._elementRef.nativeElement`.\n```Typescript\n    inkBar: ElementRef;\n\n    shopLinks = [\n        { path: 'plans', label: 'Plans' },\n        { path: 'phones', label: 'Phones' },\n        { path: 'accessories', label: 'Accessories' }\n    ];\n    activeInkBarClass: string;\n```\nThe variable `routerEventsUnsubscribe` is declared and typed as a new `Subject`. You'll see within `ngOnInit()`, we are using this variable inside `takeUntil` (provided via rxjs) so that we unsubscribe to our `router.events`. I subscription to `router.events` was necessary because the function to dynamically size the inkBar needs to be called whether a user clicks on a tab, navigates forward or backward, or navigates to the page via URL.\n```Typescript\n    routerEventsUnsubscribe = new Subject<void>();\n\n    constructor(public router: Router, public renderer: Renderer2) {}\n\n    ngOnInit() {\n        this.router.events.takeUntil(this.routerEventsUnsubscribe).subscribe((e: Event) => {\n            if (e instanceof NavigationEnd) {\n                switch (e.url) {\n                    case '/shop/plans':\n                        this.doSomething(0);\n                        return;\n                    case '/shop/phones':\n                        this.doSomething(1);\n                        return;\n                    case '/shop/accessories':\n                        this.doSomething(2);\n                        return;\n                }\n            }\n        });\n        this.router.navigateByUrl('shop/plans');\n\n        this.shopNav._inkBar._elementRef.nativeElement.classList.add('plans');\n    }\n```\nAs previously described, the variable `inkBar` is assigned after the view has initialized. The function (poorly & temporarily named..) `doSomething` is also called with the default landing path index of 0. \n```Typescript\n    ngAfterViewInit() {\n        this.inkBar = this.shopNav._inkBar._elementRef;\n        this.doSomething(0);\n    }\n```\nUpon component destruction, we set `this.routerEventsUnsubscribe.complete()` so the subscription to `router.events` is terminated.\n```Typescript\n    ngOnDestroy() {\n        this.routerEventsUnsubscribe.next();\n        this.routerEventsUnsubscribe.complete();\n    }\n```\nIn order to base the inkBar width off the tab text width, the `min-width` for `.mat-tab-link` had to be changed from `160px` to `fit-content`. `doSomething` receives a number for the index coorsponding to the active tab. First we grab the `offsetWidth` and `offsetLeft` of the `tabLink`'s nativeElement. \nSince the default padding on the tabs was `24px` and the request was to have the inkBar extend `4px` for left and right sides of the tab text, we create a variable `widthMinusPadding` and assign it a value of `width - 40`. The `left` value of the inkBar also needed to be adjusted, hence the `leftMinus` const that was created. Utilizing the `renderer` functionallity from Angular, we can then remove the existing `width` and `left` style values from the inkBar and assign it the newly created values. These functions are wrapped in a `setTimeout` call to allow for the inkbar element to become available.\n```Typescript\n    doSomething(index: number) {\n        const width = this.shopNav._tabLinks._results[index]._elementRef.nativeElement.offsetWidth;\n        const left = this.shopNav._tabLinks._results[index]._elementRef.nativeElement.offsetLeft;\n        const widthMinusPadding = width - 40 + 'px';\n        const leftMinus = left - 20 + 'px';\n        this.inkBar.nativeElement.classList.remove(this.activeInkBarClass);\n        setTimeout(() => {\n            this.renderer.removeStyle(this.inkBar.nativeElement, 'width');\n            this.renderer.setStyle(this.inkBar.nativeElement, 'width', widthMinusPadding);\n            this.renderer.removeStyle(this.inkBar.nativeElement, 'left');\n            this.renderer.setStyle(this.inkBar.nativeElement, 'left', leftMinus);\n        }, 100);\n        this.activeInkBarClass = this.shopLinks[index].path;\n    }\n}\n```\n\n![](assets/images/0D1DE51C95067099AA773EFD740EE10D.jpg)\n\n![](assets/images/CD1C8F4D7EC48D11AF9B7D00C61C7472.jpg)\n\n![](assets/images/CA50A1A0F7162AFA5238174AFB3236B2.jpg)\n\n","frontmatter":"layout : post\ntitle : Angular Dynamic Styles\ntopic: angular\ntype: article\ncategories : blog\npermalink : /blog/Angular-Dynamic-Styles/\ncomments : true\nexcerpt: Solution to a problem that needed dynamic styling.\nseo__desc : solution to produce dynamic styling\nseo__key : Angular, styling, Angular Material, Denver CO","path":"assets/posts/2018-05-01-dynamic-styles.md"},{"attributes":{"layout":"other","title":"Mentioned in NgRx 8 release article for my contribution to router selectors","link":"https://medium.com/ngrx/announcing-ngrx-version-8-ngrx-data-create-functions-runtime-checks-and-mock-selectors-a44fac112627","linkTitle":"Announcing NgRx Version 8: @ngrx/data, creator functions, run-time checks, and isolated tests","urlTitle":"Mentioned-in-NgRx-8-release-article-for-my-contribution-to-router-selectors","id":2},"body":"","frontmatter":"layout : other\ntitle : Mentioned in NgRx 8 release article for my contribution to router selectors\nlink : https://medium.com/ngrx/announcing-ngrx-version-8-ngrx-data-create-functions-runtime-checks-and-mock-selectors-a44fac112627\nlinkTitle : \"Announcing NgRx Version 8: @ngrx/data, creator functions, run-time checks, and isolated tests\"","path":"assets/posts/2019-06-19-ngrx-version-8-mention.md"},{"attributes":{"layout":"other","title":"Presentation at Rocky Mountain Angular meetup on Monorepos with Angular Workspaces","link":"https://embed.vidello.com/3183/7mxn75j3pttem1a9/index.html","linkTitle":"Meetup video","urlTitle":"Presentation-at-Rocky-Mountain-Angular-meetup-on-Monorepos-with-Angular-Workspaces","id":3},"body":"","frontmatter":"layout : other\ntitle : Presentation at Rocky Mountain Angular meetup on Monorepos with Angular Workspaces\nlink : https://embed.vidello.com/3183/7mxn75j3pttem1a9/index.html\nlinkTitle : \"Meetup video\"","path":"assets/posts/2019-09-24-monorepo-angular-workspaces.md"},{"attributes":{"layout":"post","title":"Handling Analytics with NgRx Effects","topic":"angular","type":"article","categories":"blog","permalink":"/blog/Handling-Analytics-with-NgRx-Effects/","comments":true,"excerpt":"Application analytics are a common part of any large scale, high traffic application. The following article covers a solution utilizing NgRx Effects to capture DOM events and make analytics calls.","seo__desc":"Angular solution utilizing NgRx Effects to capture DOM events and make analytics calls","seo__key":"Angular, analytics, NgRx, Denver CO","urlTitle":"Handling-Analytics-with-NgRx-Effects","id":4},"body":"Most large scale, high traffic applications have some form of analytics bound to it. Within the company that I work at, analytics are a very crucial part of what will build. In this post I will explain how myself and a few others from our team came up with a method to utilize NgRx Effects to listen for DOM interaction to map analytics calls and send to our internal backend analytics api. Lets get started...\n\n### Initial Setup\nThe implementation inside our project at work is a lot more complex than what I will cover in this post so for sake of simplicity, we can begin with a new Angular project.\n\n`ng new Analytics` then `cd Analytics`\n\nNow that you have the application created, you will need to add 'store' and 'effects' from NgRx.\n\n`ng add @ngrx/store`\n\n`ng add @ngrx/effects`\n\nNext we can start to scaffold out the example project. The following is the tree structure for how the project will look, starting within the app directory. If you prefer, you can create each of the files now or as I explain each one. \n![IMAGE](assets/images/98BECBF83941A6D00F809F3EAA48A587.jpg)\n\n- - -\n\n### Build out Analytics files\n\nThe first file we will focus on is the *analytics.effects.ts* file. This is where the functionality that catches all the DOM interaction resides and processes the events to make sure analytics calls are made correctly. \n\nA `const` is declared, before our effects class, that will be used to filter out any DOM events that do not include either `data_analytics` or a *data-analytics* attribuite associated with it. These properties and their usage will be explained in more detail later on. For now just know that these are what we attach our analytics to.\n\n```typescript\n// analytics.effects.ts\nimport { Injectable } from '@angular/core';\nimport { Effect } from '@ngrx/effects';\nimport { filter, tap } from 'rxjs/operators';\nimport { fromEvent, merge } from 'rxjs';\nimport { AnalyticsData, analyticsValidPayloads } from './analytics.map';\nimport { AnalyticsService } from './analytics.service';\nimport { AnalyticsUtilities } from './analytics.utilities';\n\nconst isValidAnalyticsTrackCallPayload = event =>\n  (event && event.detail && event.detail.data_analytics) ||\n  (event && event.target && event.target.hasAttribute && event.target.hasAttribute('data-analytics'));\n\n@Injectable()\nexport class AnalyticsEffects {\n```\n\nTwo variables are declared right inside our *AnalyticsEffects* class. One triggering on 'click' events within `document` and the other triggering on a custom event named 'customAnalytics'. \n\n```typescript\n// analytics.effects.ts\n@Injectable()\nexport class AnalyticsEffects {\n  click$ = fromEvent(document, 'click');\n  customEvent$ = fromEvent(document, 'customAnalytics');\n```\n\nBefore getting into the details of the effect, go ahead and jump to the bottom of the *AnalyticsEffects* class and create the following constuctor.\n\n```typescript\n// analytics.effects.ts\nconstructor(\n    private analyticsService: AnalyticsService,\n    private analyticsUtilities: AnalyticsUtilities\n  ) {}\n```\n\nCreate an effect and set the `dispatch` to false. Our effect is only listening for events and will not be dispatching any actions. For this example, I have named the effect `analyticsTrackCall$` and set it to pipe the merged values of the `click$` and `customEvents$` Observables, utilizing the `isValidAnalyticsTrackCallPayload` const we previously created to filter unwanted events.\n\n```typescript\n// analytics.effects.ts\n@Effect({ dispatch: false })\n  analyticsTrackCall$ = merge(this.click$, this.customEvent$).pipe(\n    filter(isValidAnalyticsTrackCallPayload),\n```\n\nNext we use `tap` and get the `event` for processing. The `analyticsEnum` variable will be be assigned a value and checked against mapping via `analyticsValidPayloads.get()`. Inside the `if` / `else if` block we are checking for two different types of analytics events. The first is checking for `event.detail.data_analytics` which is a `CustomEvent` that we build to handle sending analytics that may require more data than a simple click event. The second check is for the simple analytics mapped to a DOM element.\n\n```typescript\n// analytics.effects.ts\n    tap(event => {\n      let analyticsEnum;\n\n      if (event && event.detail && event.detail.data_analytics) {\n        analyticsEnum = event.detail.data_analytics;\n      } else if (event && event.target) {\n        analyticsEnum = event.target.getAttribute('data-analytics');\n      }\n\n```\n\nOnce we have checked the `event` and have a value assigned to our `analyticsEnum`, we pass it to `analyticsValidPayloads.get(analyticsEnum)`. `AnalyticsData` and `analyticsValidPayloads` both come from our *analytics.map.ts* file. Make sure you have the following import at the top of your *analytics.effects.ts* file.\n`import { AnalyticsData, analyticsValidPayloads } from './analytics.map';`\n\nBy sending the `analyticsEnum` to `analyticsValidPayloads`, we can map the item to `AnalyticsData` type but more importantly, we can process custom requests. \n\n```typescript\n// analytics.effects.ts\n      let analyticsEvent: AnalyticsData = analyticsValidPayloads.get(analyticsEnum);\n\n      // If there was no analytics map for EID, create analyticsData object with only EID\n      if (analyticsEvent === undefined) {\n        analyticsEvent = { eid: analyticsEnum };\n      }\n```\n\nTaking a look at the *analytics.map.ts* file, you can see the interface for `AnalyticsData` with two properties, `eid` and `data`. The neat part is what happens when the `analyticsValidPayloads.get(analyticsEnum)` call is made from our *analytics.effects.ts* file and a `analyticsValidPayloads` `.set()` parameter matches the passed in enum value. When a match is mapped, we construct a new `AnalyticsData` object with custom `data` that will then be used back in the effect. Don't worry if this isn't clear right now. After walking through the code, I will show examples of this working.  \n\n```typescript\n// analytics.map.ts\nimport { AnalyticsEidEnum } from './analytics-eid.enum';\n\nexport interface AnalyticsData {\n  eid: string;\n  data?: {};\n}\n\nexport const analyticsValidPayloads: Map<string, AnalyticsData> = new Map<string, AnalyticsData>();\n\nanalyticsValidPayloads.set(AnalyticsEidEnum.form_close, {\n  eid: AnalyticsEidEnum.form_close,\n  data: {\n    formPristine: 'getFormPristine'\n  }\n});\n```\n\nBack in the *analytics.effects.ts* file we do some more checks to determine how to construct the final analytics object. If the `event` has `data_adHoc`, we go ahead send that data along with the `eid` to the *AnalyticsService*. \n\nNext we check the `analyticsEvent` that was assigned a value earlier via `analyticsValidPayloads.get()` for `data`; If the the `analyticsEvent` does have `data`, we take each `key`, assign it to const `analyticsFn` which then allows us to index into `analyticsUtilities` to call the matching function, passing in `event` as the parameter. Looking back to when we constructed to object above with `data: {formPristine: 'getFormPristine'}`, `analyticsFn` would be `formPristine`, therefore calling the `getFormPristine(event)` function in *AnalyticsUtilities* and assigning the the returned value to `adHocData`. Finally, the `eid` and `[adHocData]` are sent to the *AnalyticsService*.\n\nIf neither of the first two checks are satisfied, we pass on the simple `eid` form of analytics data to *AnalyticsService*.\n\n```typescript\n// analytics.effects.ts\n      if (event.detail.data_adHoc) {\n        this.analyticsService.track(analyticsEvent.eid, [event.detail.data_adHoc]);\n      } else if (analyticsEvent.data) {\n        const adHocData = {};\n        Object.keys(analyticsEvent.data).forEach(key => {\n          const analyticsFn = analyticsEvent.data[key];\n          adHocData[key] = this.analyticsUtilities[analyticsFn](event);\n        });\n        this.analyticsService.track(analyticsEvent.eid, [adHocData]);\n      } else {\n        this.analyticsService.track(analyticsEvent.eid);\n      }\n    })\n  );\n```\n\n```typescript\n// analytics.effects.ts\n@Effect({ dispatch: false })\n  analyticsTrackCall$ = merge(this.click$, this.customEvent$).pipe(\n    filter(isValidAnalyticsTrackCallPayload),\n    tap(event => {\n      let analyticsEnum;\n\n      if (event && event.detail && event.detail.data_analytics) {\n        analyticsEnum = event.detail.data_analytics;\n      } else if (event && event.target) {\n        analyticsEnum = event.target.getAttribute('data-analytics');\n      }\n\n      let analyticsEvent: AnalyticsData = analyticsValidPayloads.get(analyticsEnum);\n\n      // If there was no analytics map for EID, create analyticsData object with only EID\n      if (analyticsEvent === undefined) {\n        analyticsEvent = { eid: analyticsEnum };\n      }\n\n      if (event.detail.data_adHoc) {\n        this.analyticsService.track(analyticsEvent.eid, [event.detail.data_adHoc]);\n      } else if (analyticsEvent.data) {\n        const adHocData = {};\n        Object.keys(analyticsEvent.data).forEach(key => {\n          const analyticsFn = analyticsEvent.data[key];\n          adHocData[key] = this.analyticsUtilities[analyticsFn](event);\n        });\n        this.analyticsService.track(analyticsEvent.eid, [adHocData]);\n      } else {\n        this.analyticsService.track(analyticsEvent.eid);\n      }\n    })\n  );\n```\n\nThe following is the *AnalyticsService*. For sake of simplicity, the `track()` function just logs out the data passed in. For real world implementation you would configure the service to send this data to your analytics api.\n\n```typescript\n// analytics.service.ts\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AnalyticsService {\n\n  constructor() {\n  }\n\n  track(id: string, rawAdHocData?: any) {\n    rawAdHocData\n      ? console.log(`id: ${id} | adHocData: ${JSON.stringify(rawAdHocData)}`)\n      : console.log(`id: ${id}`);\n  }\n}\n```\n\nThe *analytics-eid.enum.ts* file hold the enums that are the `eid` for each analytics call.\n\n```typescript\n// analytics-eid.enum.ts\nexport enum AnalyticsEidEnum {\n  form_name = 'analyticsApp_submit_form_nameForm',\n  form_close = 'analyticsApp_action_form_close',\n  btn_cancel = 'analyticsApp_action_button_genericCancel',\n  btn_submit = 'analyticsApp_action_button_genericSubmit'\n}\n```\n\nThe *analytics.utilities.ts* file holds the function for creating a new `CustomEvent`. You may notice the new `CustomEvent` typeArg is set to 'customAnalytics'. This coordinates with the `customEvent$` Observable we decalred at the beginning of the effect. We then dispatch this newly created `customEvent` to the `document` which allows it to be picked up in the effect. We will see how this function is used in just a bit. \n\nThis file also holds any special functions you want to define. In this example we have the `getFormPristine(event)` function. I touched on how this function is called a little earlier.\n\n```typescript\n// analytics.utilities.ts\nimport { DOCUMENT } from '@angular/common';\nimport { Inject, Injectable } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class AnalyticsUtilities {\n  constructor(@Inject(DOCUMENT) private document: Document) {\n  }\n\n  public customAnalyticsEvent(analyticsMapId: string, adHocData?): void {\n    const customEvent = new CustomEvent('customAnalytics', {\n      detail: {\n        data_analytics: analyticsMapId,\n        data_adHoc: adHocData\n      }\n    });\n    this.document.dispatchEvent(customEvent);\n  }\n\n  public getFormPristine(event) {\n    return event.target.value;\n  }\n}\n```\n\n### Build out App files\n\nNow that I have covered the files that handle the analytics functionality of the application, we can take a look at the *app.component* files to see how we can make use of the analytics code. \n\nInside the *app.module.ts* file we have `EffectsModule.forRoot([AnalyticsEffects])` declared in the imports. This will give application wide access to the *AnalyticsEffects*.\n\nWalking down the *AppComponent*, you'll see we have a couple variables and a form. In the constructor we have *AnalyticsUtilities*. In the `onSubmit()` function we call `handleFormAnalytics()`. This function loops over the controls of our form and builds up the `adHocData` array with each control name and the length of value within each control. Next it calls `customAnalyticsEvent` inside our *AnalyticsUtilities* with `AnalyticsEidEnum.form_name` as the eid and `adHocData` as our analytics data.\n\n```typescript\n// app.component.ts\nimport { Component } from '@angular/core';\nimport { FormControl, FormGroup } from '@angular/forms';\nimport { AnalyticsEidEnum } from './analytics/analytics-eid.enum';\nimport { AnalyticsUtilities } from './analytics/analytics.utilities';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  public readonly title = 'analytics';\n  public readonly analyticsEidEnum = AnalyticsEidEnum;\n  public showForm = true;\n  public nameForm: FormGroup = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n  });\n\n  constructor(private analyticsUtilities: AnalyticsUtilities) {\n  }\n\n  onSubmit() {\n    this.handleFormAnalytics();\n  }\n\n  toggleForm() {\n    this.showForm = !this.showForm;\n  }\n  \n  private handleFormAnalytics() {\n    const adHocData = [];\n    Object.keys(this.nameForm.controls).forEach(key => {\n      adHocData.push({\n        controlName: key,\n        valueLength: this.nameForm.controls[key].pristine ? 0 : this.nameForm.controls[key].value.length\n      });\n    });\n    this.analyticsUtilities.customAnalyticsEvent(\n      AnalyticsEidEnum.form_name,\n      adHocData\n    );\n  }\n}\n```\n\nThe *app.component.html* file is below. The first element to observe is the `form` element. Upon submission of the form, `onSubmit()` is called which as we saw above calls `handleFormAnalytics()` with values from the form group. Next we have a button for closing the form. There are two parts on the button that help us with gathering analytics when the form is closed. First `[attr.data-analytics]=\"analyticsEidEnum.form_close\"` and then `[value]=\"nameForm.pristine\"`. The 'data-analytics' attribute gets picked up in the *AnalyticsEffects* class and when mapped, `.form_close` enum is detected and `data: {formPristine: 'getFormPristine'}` is added. Then when `getFormPristine(event)` is called, the value provided via `[value]=\"nameForm.pristine\"` is used. This example will provide analytics showing is a user started to complete the form before closing it. Simple, but just an example. \n\nLast we have two more buttons, Cancel and Submit, that have simple generic analytics attributes:\n\n`[attr.data-analytics]=\"analyticsEidEnum.btn_cancel\"`\n\n`[attr.data-analytics]=\"analyticsEidEnum.btn_submit\"`\n\n```typescript\n// app.component.html\n<div id=\"form-container\">\n  <form *ngIf=\"showForm\" [formGroup]=\"nameForm\" (ngSubmit)=\"onSubmit()\" class=\"name-form\">\n  <button class=\"btn-close\" (click)=\"toggleForm()\" [attr.data-analytics]=\"analyticsEidEnum.form_close\" [value]=\"nameForm.pristine\">X</button>\n\n    <mat-form-field class=\"name-full-width\">\n      <input formControlName=\"firstName\" matInput placeholder=\"First Name: \" required>\n    </mat-form-field>\n\n    <mat-form-field class=\"name-full-width\" >\n      <input formControlName=\"lastName\" matInput placeholder=\"Last Name: \" required>\n    </mat-form-field>\n\n    <button mat-raised-button [attr.data-analytics]=\"analyticsEidEnum.btn_cancel\" type=\"button\">Cancel</button>\n    <button mat-raised-button color=\"primary\" [attr.data-analytics]=\"analyticsEidEnum.btn_submit\" type=\"submit\">Submit</button>\n  </form>\n  <button mat-raised-button color=\"primary\" class=\"btn-open\" *ngIf=\"!showForm\" (click)=\"toggleForm()\">Open Form</button>\n</div>\n```\n\n### Try it all out\n\nNow lets take a look at these calls in action!\n\nHere is the simple form for this example:\n![IMAGE](assets/images/AB36DE5E6055EB8DF8FDA10F92177C34.jpg)\n\nFirst lets see what happens when we click the Cancel button that has the simple generic analytics call on it. \nWe see the value of the enum picked up by the effect:\n![IMAGE](assets/images/CA13A4CEC7B6480AFF19E1471E9B4E0D.jpg)\n\nNext we see that the event fell through the first two checks because it is simple and only contains an eid:\n![IMAGE](assets/images/86C98F3DB2EA25664F0093F5447C25CC.jpg)\n\nLooking at the console we see the result logged inside *AnalyticsService*:\n![IMAGE](assets/images/5AF1C4655C91B4EC7E9AF39180728DB0.jpg)\n\nNext lets take a look at what happens when we close the form. \n\nValue of enum:\n![IMAGE](assets/images/3E26FDA5F754B23F1F7D84CA1D25562D.jpg)\n\nResulting Object from `analyticsValidPayloads.get(analyticsEnum)`:\n![IMAGE](assets/images/41B97112E82BFE942A758C86D9CF9399.jpg)\n\nSince the Object has `data` on it, it lands in the `else if` block where each of the keys of `analyticsEvent.data` are processed. This Object only has one key to process, 'formPristine'.\n\nResult logged inside *AnalyticsService*:\n![IMAGE](assets/images/7DF16946DACE0BA5D7827AC8DFBCBD50.jpg)\n\nResult logged inside *AnalyticsService* after entering values into form:\n![IMAGE](assets/images/DC1B09898D9EABC038DF870244F66A54.jpg)\n\nLast we look what happens when we submit the form with values. \n\nHere is the form with three characters in the First Name field and six characters in the Last Name field:\n\n![IMAGE](assets/images/B75915D6D37F4516EFE4831A1B553689.jpg)\n\nWhen the event is checked inside our effect, the first `if` is satisfied because the event has `data_adHoc` which was set inside the *AppComponent* upon form submission. You can see the data contains the control names and the length of the values within those controls:\n![IMAGE](assets/images/51FFB33386B700F90F1436B72DFD2436.jpg)\n\nResult logged inside *AnalyticsService*:\n![IMAGE](assets/images/8861D3FF89B160A1E9D16147E99973BF.jpg)\n\n### Summary\nAs demonstrated in this article, NgRx Effects can be utilized to perform a frequent task such as analytics calls. Structuring you api call, enums, and data may be unique to each individual project but the basic concepts are transferable. \n\nI hope you enjoyed this article and found it helpful. Leave a comment below and let me know what you think!\n","frontmatter":"layout : post\ntitle : Handling Analytics with NgRx Effects\ntopic: angular\ntype: article\ncategories : blog\npermalink : /blog/Handling-Analytics-with-NgRx-Effects/\ncomments : true\nexcerpt: Application analytics are a common part of any large scale, high traffic application. The following article covers a solution utilizing NgRx Effects to capture DOM events and make analytics calls.\nseo__desc : Angular solution utilizing NgRx Effects to capture DOM events and make analytics calls\nseo__key : Angular, analytics, NgRx, Denver CO","path":"assets/posts/2019-10-30-handling-application-analytics-with-ngrx-effects.md"}]